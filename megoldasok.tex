% -*- fill-column: 52 -*-
% (local-set-key (kbd "C-c C-f") 'display-fill-column-indicator-mode)

\chapter{A feladatok megoldásai}
\subsubsection*{1.~feladat}
\begin{query}
?- szülő(huszajn, X).
false

?- szülő(X, huszajn).
X = ali ;
X = fátima

?- szülő(ámna, X), szülő(X, fátima).
X = mohamed

?- szülő(ámna, X), szülő(X, Y), szülő(Y, haszan).
X = mohamed,
Y = fátima
\end{query}
\subsubsection*{2.~feladat}
\begin{query}
?- szülő(X, ali).
?- szülő(umáma, X).
?- szülő(X, zajnab), szülő(Nagyszülő, X).
\end{query}
\subsubsection*{4.~feladat}
\begin{program}
boldog(X) :- vangyereke(X).
kétgyerekes(X) :- szülő(X, Y), fivér(Y, _).
\end{program}
\subsubsection*{5.~feladat}
\begin{program}
unoka(X, Y) :- nagyszülő(Y, X).
\end{program}
\subsubsection*{6.~feladat}
\begin{program}
nővér(X, Y) :-
    nő(X),
    szülő(Z, X), szülő(Z, Y),
    X \= Y.
nagynéni(X, Y) :- nővér(X, Z), szülő(Z, Y).
\end{program}
\begin{query}
?- nagynéni(zajnab, X), férfi(X).
\end{query}
\subsubsection*{7.~feladat}
Jó a definíció; X őse Z-nek, ha (i) X szülője Z-nek, vagy (ii) X őse Z szülőjének.
\subsubsection*{8.~feladat}
Változó; atom; atom; változó; atom; struktúra; szám; (hibás); struktúra; (hibás).
\subsubsection*{9.~feladat}
Erre a feladatra nincs \emph{egyetlenegy} jó megoldás; különböző alkalmazásokhoz
más és más leírási módok lehetnek kényelmesebbek.
\begin{itemize}
\item Egy tengelyekkel párhuzamos téglalapot le lehet (pl.) írni a bal
  felső és jobb alsó sarkával, tehát \pr{téglalap(BalFelső, JobbAlsó)},
  ahol \pr{BalFelső} és \pr{JobbAlsó} pontok: \pr{pont(X, Y)}.  Ha a
  téglalap a tengelyekkel nem párhuzamos, akkor a legegyszerűbb talán
  mind a négy csúcspontot felsorolni (bár ez redundáns).
  Egy másik lehetőség, hogy egy irányított szakasszal és egy hosszal
  írjuk le: \pr{téglalap( szakasz(P1,P2),Hossz)}; ez alapján a téglalap
  úgy szerkeszthető meg, hogy a szakasz
  lerajzolása után derékszögben balra fordulunk,
  és onnan felmérjük a hosszt, a negyedik csúcs pedig már adódik.
\item Egy négyzetet mindig le lehet írni a bal felső és jobb alsó
  sarokkal, de lehet pl.~a középponttal és egy csúcsponttal is;
  tengelyekkel párhuzamos esetben elég a középpont és a csúcsok ettől
  való távolsága is.
\item Egy kört is reprezentálhat a befoglaló négyzete, de megadható a
  középpontja és a sugara által is: \pr{kör(Középpont, Sugár)},
  pl.~\pr{kör(pont(1,2),3)}.
\end{itemize}
\subsubsection*{10.~feladat}
\begin{program}
vízszintes(szakasz(pont(_,Y),pont(_,Y))).
\end{program}
\begin{query}
?- vízszintes(S), függőleges(S).
S = szakasz(pont(_X,_Y),pont(_X,_Y)).
\end{query}
Tehát a ponttá degenerált szakasz ilyen.
\subsubsection*{11.~feladat}
Igen (\pr{A=1,B=2}); nem; nem; igen (\pr{D=2,E=2});
nem;
igen (\pr{P1= pont(-1,0),P2=pont(1,0),P3=pont(0,Y)}).
\subsubsection*{12.~feladat}
A megoldás függ a választott reprezentációtól.
Ha a négy csúcsponttal
írtuk le:
\begin{program}
tengelytéglalap(téglalap(A,B,_,_)) :-
    függőleges(szakasz(P1,P2)).
tengelytéglalap(téglalap(_,B,C,_)) :-
    függőleges(szakasz(P2,P3)).
\end{program}
Ha az irányított szakasz és hossz megoldást
választottuk:
\begin{program}
tengelytéglalap(téglalap(S,_)) :- függőleges(S).
tengelytéglalap(téglalap(S,_)) :- vízszintes(S).
\end{program}
Természetesen sok más megoldás is elképzelhető.
\subsubsection*{13.~feladat}
\begin{program}
kiolvas(1, egy).
kiolvas(2, kettő).
kiolvas(3, három).
\end{program}
\subsubsection*{14.~feladat}
\begin{query}
?- f(s(1), A).
A = kettő.
\end{query}
Csak a második szabállyal egyesíthető.

\begin{query}
?- f(s(s(1)), kettő).
false.
\end{query}
Nincsen egyesíthető szabály.

\begin{query}
?- f(s(s(s(s(s(s(1)))))), C).
C = egy.
\end{query}
Nézzük ezt meg lépésenként.
Az eredeti kérdés csak a negyedik szabállyal egyesíthető;
egyesítés után az
\begin{query}
?- f(s(s(s(1))), C).
\end{query}
kérdést kell megválaszolni, ami ismét a negyedik szabállyal
egyesíthető, tehát:
\begin{query}
?- f(1, C).
\end{query}
Ez pedig az első szabály alapján adja az eredményt.

\begin{query}
?- f(D, három).
D = s(s(1)) ;
D = s(s(s(s(s(1))))) ;
D = s(s(s(s(s(s(s(s(1)))))))) ;
...
\end{query}
A harmadik szabály adja az első megoldást.
A negyedik szabály szerint, ha
\begin{query}
?- f(X, három).
\end{query}
teljesül, akkor \pr{D = s(s(s(X)))}, ez alapján
minden olyan \pr{D} megoldás lesz, ahol $3n+2$ db.~\pr{s}
szerepel.
\subsubsection*{15.~feladat}
\begin{query}
trace, nagy(X), sötét(X), notrace.
Call: nagy(_5078)
Exit: nagy(medve)
Call: sötét(medve)
  Call: fekete(medve)
  Fail: fekete(medve)
Redo: sötét(medve)
  Call: barna(medve)
  Exit: barna(medve)
Exit: sötét(medve)
X = medve 
\end{query}
\subsubsection*{16.~feladat}
A nyomkövetés a \pr{fekete(X)} kielégítésétől indul.
A \pr{notrace} hozzáadásával a nyomkövetés csak addig tart,
amíg el nem jut a \pr{sötét} második szabályához:
\begin{query}
?- sötét(X), nagy(X).
  Call: fekete(_4284)
  Exit: fekete(macska)
Exit: sötét(macska)
Call: nagy(macska)
Fail: nagy(macska)
Redo: sötét(_4284)
X = medve.
\end{query}
\subsubsection*{17.~feladat}
Amikor további bizonyítást keresünk, a második szabály alapján
Fátimának egy másik ősét (nem Mohamedet) fogja keresni,
akiről aztán majd be akarja látni, hogy Abdulla gyermeke.

Ekkor azonban eljutunk a második szabályhoz úgy, hogy az \pr{X}
ismeretlen, és a szabály szerint az
\begin{query}
?- ős3(X, fátima).
\end{query}
kérdés megválaszolásához először meg kell válaszolni az
\begin{query}
?- ős3(Y, fátima).
\end{query}
kérdést -- ez viszont nyilvánvalóan egy végtelen rekurzió.
